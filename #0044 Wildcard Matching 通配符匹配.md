### 通配符匹配
### Wildcard Matching

> 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。  
> - `'?'` 可以匹配任何单个字符。  
> - `'*'` 可以匹配任意字符串（包括空字符串）。  
> 
> 两个字符串完全匹配才算匹配成功。  
> **说明**:  
> `s` 可能为空，且只包含从 `a-z` 的小写字母。  
> `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `?` 和 `*`。  

----------

#### I 动态规划

类似正则匹配，可以通过动态规划解决问题  
思考能完成匹配的情况只有以下几种（假定此时 `s` 为 `0 ~ index` 的子串，`p` 为 `0 ~ index2` 的子串）：
1. `p[index] == '*'`，此时有两种情况可以完成匹配
   - `p[index - 1]` 组成的子串和 `s[index2]` 组成的子串可以匹配，此时由于 `'*'` 可表示空字符，所以必然能匹配
   - `p[index]` 组成的子串和 `s[index2 - 1]` 组成的子串可以匹配，此时由于 `'*'` 可表示任意长字符串，所以即使 `s` 增加了一个字母也能匹配  
2. `p[index] == '?'`，此时只要 `p[index - 1]` 和 `s[index2 - 1]` 能匹配，就必能匹配  
3. `p[index] == s[index2]`，此时同 2 情况  

分类讨论进行动态规划即可  

```cpp
bool isMatch(string s, string p) 
{
    int m = s.size();
    int n = p.size();
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;
    for(int i = 1; i <= n; ++i)
    {
        if(p[i - 1] == '*')
            dp[0][i] = true;
        else
            break;
    }
    for(int i = 1; i <= m; ++i)
    {
        for(int j = 1; j <= n; ++j)
        {
            if(p[j - 1] == '*')
                dp[i][j] = dp[i][j - 1] | dp[i - 1][j];
            else if(p[j - 1] == '?' || s[i - 1] == p[j - 1])
                dp[i][j] = dp[i - 1][j - 1];
        }
    }
    return dp[m][n];
}
```
