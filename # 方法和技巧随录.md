> 2022年4月20日 UTC时间7:30  
> 准备暑期实习到头晕眼花，仔细思索，发现近期在算法题方面的进展开始变得缓慢起来，原因有二  
> - 一方面，由于刷满了预先的目标500题，现在的刷题量有所减少，同时需要把时间让位给自己的课题和其他的基础知识  
> - 另一方面，近乎不考虑知识点方向的无脑刷题让我缺少了一个系统性总结的过程  
> 
> 在被两道并不算很难的中等题困扰了许久之后，决定记录下从现在开始，无论是复习还是做新题遇到的比较有意思的题解思路，  
> 一方面，便于自己系统性总结各种问题的解决技巧，另一方面也当做后续自己的复习或者学习的笔记  

## 数组

### 前缀和
#### 描述
一维数组 `a[n]`，其任意位置的前缀和 `pre[i]` 为 `pre[i] = pre[i - 1] + a[i]`  
二维数组 `a[m][n]`，其任意位置的前缀和 `pre[i][j]` 为 `pre[i][j] = a[i][j] + pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1]`  
利用前缀和，可以快速求出根据定义可以看到，前缀和即为从数组起点到 `i` 或者 `{i, j}` 位置的所有点的大小之和  
因此可以利用前缀和快速求出任意范围内的数组和  
利用提前处理数组获得前缀和数组，可以避免后续算法处理需要多次计算重复的数组和的问题  
#### 题目举例
[0427 Construct Quad Tree 建立四叉树](./%230427%20Construct%20Quad%20Tree%20建立四叉树.md)  

### 差分数组
#### 描述
对于一个数组 `a[n]`，其差分数组中的任意值为 `d[i] = a[i] - a[i -1]`，除了 `d[0] = a[0]`  
差分数组的存在使得频繁的数组改动可以减少工作量，比如对某个区间加上同样的数字，这时差分数组只有区间最开始的前一个位置和最后的后一个位置的值发生了变化  
因此总体改动次数减少了  
此外，当需要求区间和时，只需要将差分数组从 `d[0]` 累加到该位置即可，时间复杂度为线性  
#### 题目举例
[1450 Number of Students Doing Homework at a Given Time 在既定时间做作业的学生](./%231450%20Number%20of%20Students%20Doing%20Homework%20at%20a%20Given%20Time%20在既定时间做作业的学生.md)

### 滑动窗口
#### 描述
滑动窗口即一个左右边界在数组上移动的子数组区间  
既然窗口内容本来就是子数组，那么此类方法就非常适合用来解决子数组问题  
找到子数组符合的规律，可以快速利用滑动窗口解决在较好的时间复杂度解决问题  
#### 题目举例
[0713 Subarray Product Less Than K 乘积小于K的子数组](./%230713%20Subarray%20Product%20Less%20Than%20K%20乘积小于K的子数组.md)  

### 原地哈希
#### 描述
利用哈希表将 `key` 和 `value` 对应便于快速查表定位或计数是一种常用的数据结构方法  
原地哈希，顾名思义，就是将相关信息记录在原地，不利用额外空间  
这种处理一般适用于数组大小和数组内的数字范围存在对应关系（比如范围相等）的情况  
此时可以利用一些技巧，例如将数组中出现的数字转换后对应的下标 `index` 位置的数字变为负数或者平方来实现**该`index`已经出现过了**的记录  
#### 题目举例
[0442 Find All Duplicates in an Array 数组中重复的数据](./%230442%20Find%20All%20Duplicates%20in%20an%20Array%20数组中重复的数据.md)

## 字符串
### KMP算法
#### 描述
KMP算法是一种用于字符串匹配的算法，假定有长串 `s` 和模式串 `mod`，KMP算法可以利用 `mod` 本身的重复性来减少多余的无用匹配过程  
KMP算法的关键是构建一个记录 `mod` 字符串信息的数组 `next`，`next` 数组解释为 **`next[i]`表示`mod[i]`出现在整个字符串`mod`最前面的连续第`i`个位置**  
举例：`mod = "ababc"`，则 `next` 数组为 `next = {0, 0, 1, 2, 0}`，因为 `next[2]` 表示 `'a'`出现在前缀的第一个位置  
这样处理 `next` 数组的目的是找出字符串的重复部分，以便于减少匹配过程  
在匹配的过程中，如果 `mod` 和 `s` 在某处不匹配，可以不用从头开始，只需要知道 `next[i]` 的值，再从符合条件的上一个字符串的位置开始匹配即可  
#### 题目举例  
[459 Repeated Substring Pattern 重复的字符串](./%230459%20Repeated%20Substring%20Pattern%20重复的字符串.md)

## 栈

### 单调栈
#### 描述
栈是一种常见的数据结构，单调栈是一种栈的特殊类型，用于记录顺序结构中具有单调递增或者递减性质的一系列数据  
在解决问题时，如果遇到如下场景，可以考虑使用单调栈：  
**对于一个数据，我们想知道其后面（或者前面）第一个比它大（或者小）数字的位置**  
在使用单调栈时，需要注意栈中存储的内容是数据本身还是指向数据的一些参数，比如数组的下标，链表的节点地址等  
#### 题目举例
[739 Daily Temperatures 每日温度](./%230739%20Daily%20Temperatures%20每日温度.md)  

### 对于涉及栈的字符串类题目中处理字符长度范围的考虑
#### 描述
有一类字符串问题，在处理时需要对字符串进行分段处理，比如括号问题，  
虽然众所周知括号问题基本无脑往栈的方向找思路就可以，但是在细节处理上仍然有很多需要注意的地方，  
如果遇到的问题在考虑当前字符串时，一些因素与之前的字符串存在关联，那么不妨考虑将当前字符串和之前的字符串一起处理  
#### 题目举例
[388 Longest Absolute File Path 文件的最长绝对路径](./%230388%20Longest%20Absolute%20File%20Path%20文件的最长绝对路径.md)  
[394 Decode String 字符串解码](./%230394%20Decode%20String%20字符串解码.md)  
[1190 Reverse Substrings Between Each Pair of Parentheses 反转每对括号间的字串](./%231190%20Reverse%20Substrings%20Between%20Each%20Pair%20of%20Parentheses%20反转每对括号间的字串.md)  

## 链表
### 利用“占位”思想解决链表遍历不方便问题
#### 描述
链表是一种常见的数据结构，其最大的问题就是定位到某个具体位置不够方便，需要对整个链表进行遍历  
在有一类问题中，对链表的处理经历了分治的过程，  
在此过程中，如果需要用到链表不同位置（但这些位置存在一定的联系）的值，一般解决办法是多次遍历，  
这时我们可以在分治的过程中利用占“占位”变量，将位置预留给没有遍历到的节点，待遍历到了再将其补上  
#### 题目举例
[109 Convert Sorted List to Binary Search Tree 有序链表转换二叉搜索树](./%230109%20Convert%20Sorted%20List%20to%20Binary%20Search%20Tree%20有序链表转换二叉搜索树.md)

## 几种求随机数的方法
### 蓄水池抽样
#### 描述
给定一个数据流，数据流长度 `N` 很大，且 `N` 直到处理完所有数据之前都不可知  
如果需要在只遍历一遍数据（`O(N)`）的情况下，随机选出具有某些特定性质的数字，就可以采用此方法  
对所有满足该性质的数字进行计数，并记录**该种类别数字出现的次数** `cnt`  
如果 `cnt` 大于需要的次数，则可以对需要的次数求随机数，并比较该数字与已有数字的下标  
如果下标小于需要的次数，则对对应下标的数字进行替换  
#### 题目举例
[398 Random Pick Index 随机数索引](./%230398%20Random%20Pick%20Index%20随机数索引.md)  
