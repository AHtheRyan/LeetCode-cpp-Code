### 灯泡开关
### Bulb Switcher

> 初始时有 `n` 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。  
> 第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 `i` 轮，你每 `i` 个灯泡就切换一个灯泡的开关。直到第 `n` 轮，你只需要切换最后一个灯泡的开关。  
> 找出并返回 `n` 轮后有多少个亮着的灯泡。  

> There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.  
> On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.  
> Return *the number of bulbs that are on after `n` rounds*.  

----------

#### I 数学

我们对 `n <= 10` 的情况进行分析，其中 `0` 表示灭，`1` 表示亮：  
| 灯数 | 第一个 | 第二个 | 第三个 | 第四个 | 第五个 | 第六个 | 第七个 | 第八个 | 第九个 | 第十个 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 2 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |
| 3 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 |
| 4 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |
| 5 | 1 | 0 | 0 | 1 | 0 | 1 | 1 | 1 | 0 | 1 |
| 6 | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 1 |
| 7 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 1 |
| 8 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1 |
| 9 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 1 |
| 10 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 |

观察上表，可见：  
1. 任何位置的灯泡之前的灯的亮暗情况不会受到后面的数字影响，例如第三位的灯变化时，`1` 和 `2` 都不会发生变化了  
2. 第 `k` 位的灯的亮暗情况取决于之前改变了几次开关，而之前改变几次开关取决于其因数的数目，即 `1 -> 0 -> 1 -> 0 -> ...`  
   - 如果因数为奇数，则灯亮
   - 如果因数为偶数，则等灭  

分析任何数的因数：`1` 和该数字本身必为因数，且除了开根号以外的因数都是成对出现的，  
因此，对于任意数字，只要不是完全平方数，则到了该位置必然灭，亮灯的总数为之前的亮灯之和，只有位于完全平方数位置的灯才会增加最终的亮灯数  
所以简单开根号即可  

```cpp
int bulbSwitch(int n) 
{
    return sqrt(n);
}
```
